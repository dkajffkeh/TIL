# 객체지향의 원리와 이해
<p align="center"><img src="images/bookCover.png" align="center"/></p>

## 01 사람을 사랑한 기술

### 어셈블리어
> 프로그래밍 언어중의 하나이며 기계어 한단계 바로 위의 언어이다. 어셈블러를 통해 기계어로 변환되어 사용된다.
어셈블리어는 고급언어와 기계어 사시에 있다하여 중간 언어 라도고 불리고있다.

### One Source Multi Use Anywhere
> OS 독립적으로 동작하며 기종별 컴파일러를 따로 구비해둘 필요가 없다

### CBD(Component Based Development)
> 애플리케이션을 통짜로 개발하지 말고 애플리케이션을 의미 있는 단위로 구분하고 그 단위를 하나 하나씩 부품으로 개발해 마치 레고 블록을 쌓아 올리듯 부품을 결합해 제품을 완성하자는 방법론.

### SOA(Service Orientec Architecture)
> 서비스 중심 구조 또는 서비스 지향 구조, 실제 현실의 업무를 기준으로 개발하는 방법론.

## 02 자바의 절차적/ 구조적 프로그래밍

### JDK, JRE, JVM

> JDK JRE JVM 을 다루기 이전 Java 프로그램의 실행에 대한 개념을 먼저 잡고가자면 JDK 컴파일 과정을 통해 생성된 .class 파일이 JVM 에 로드되어 바이트 코드를 해석 하여 메모리 등의
> 리소스를 할당 관리하면서 정보를 처리하는 일련위 작업을 말한다.

- JDK (Java Development Kit) 는 자바 가상머신(JVM, JRE) 와 함께 프로그래밍에 사용되는 3대 핵심 기술 패키지 가운데 하나이다. 쉽게 말해 JVM 과 JRE 에 의해 실행되고
구동될 수 있는 자바 프로그램을 생성할 수 있게 해준다. 하여 JDK 의 범주는 JRE 와 JVM 모두를 포함하는 범주로 분류되며 독립적으로 존재할시 그 자체로 작성된 코드를 실행시켜볼 수 없을 것이다.

 <p align="center"><img src="images/jdkjrejvmImage.png"/></p>


- JRE 는 JDK 에서 개발된 프로그램을 클래스 로더를 거쳐 만들어진 .class 파일들의 바이트 코드를 JVM 을 거쳐 실제 구동될 수있는 환경을 제공하는 영역으로 정리될 수 있다.
- JVM 은 스택기반의 자바 가상머신 (Java Virtual Machine) 으로 클래스 로더로부터 읽어온 바이트코드를 실제 실행하는 머신이다. 총 5가지의 큰 범주로 분리 되며 
  PC Register (Area), Stack, Native method stack, Method Area, Heap  
    ##### PC Register
    - 프로그램의 실행은 CPU 에서 명령어 즉 instruction (연산지시자) 을 수행하는 과정으로 이루어진다. 이러한 instruction 을 수행하는 동안 필요한 정보를 레지스터 라고 하는데 CPU내의 기억장치를 이용한다.
      > 1 + 2 라는 연산을 수행하는 경우 연산에 필요한 데이터 1, 2, + 연산이 있다. 연산을 수행하다보면 1이라는값과 2라는 값을 받은 후 이 숫자를 더한 결과값을 내는 과정으로 진행된다.
      > 1과 2처럼 명령에 실행되는 데이터를 Operand(피연산자) 라 하며 더하기 연산 명령과 같은 instruction 도 존재한다. CPU 는 이 모든것을 기억하고 있어야 연산과정을 처리 할 수 있으며
      > 3이라는 Operand 도 처리 결과를 메모리로 전송해야 하기 때문에 어딘가에 잠시 머물러야 한다. 이떄 사용되는것이 CPU 레지스터 이다.
      > 하지만 JVM 의 PC register 영역은 CPU 에 직접 연산지시자를 수행하지 않고 Stack 영역에서 피연산자를 별도로 뽑아 메모리 공간에 저장하는 방식을 취하는데 이를 PC Register 가 관할한다.
    - 자바는 플랫폼에 독립적이기는 하나 OS나 CPU 의 입장에서 보면 하나의 프로세스에 지나지 않기 때문에 머신의 리소스를 사용한다. 
    - PCRegister Thread 마다 하나씩 존재하며 CPU 로 보내는 Instruction 을 제공하기전 버퍼공간으로 활용하게 된다.
    
    ##### Stack (Area)
    - 기본 자료형 primitive 에 해당되는 지역변수가 저장되는 공간이다. 해당 메소드 호출될 때 메모리에 할당되고 종료되면 메모리가 해제되는 구조이다. 
    - 원시타입의경우 참조값을 저장하는것이 아니라 실제 stack 에 값이 저장된다.
    - 커스텀 오브젝트 Heap 영역에 할당관 데이터의 참조값이 할당된다.
      <p align="center"><img src="images/javaSampleCode.png"/></p>
        <br>
      <p align="center"><img src="images/stackandheap.png"/></p>
      Stack 영역의 변수는 scope 를 갖고 있으며 해당 영역이 소진되지 않고 쌓이는 로직만 계속 된다면 스텍영역넘침 현상 StackOverFlow Exception 이 발생한다.
    
    ##### Heap
    - Heap 영역은 Instance(Object) 와 Array 객체 단 두가지 종류만 저장되는 공간이며 모든 Thread 에 의해 공유되는 영역이다.
    - 애플리케이션 내 Thread 사이에서 공유된 Heap 영역 데이터를 이용할 경우 동기화 이슈가 발생할 수 있다.
    - Heap 메모리의 해제는 오로지 ***G.C*** 를 통해서만 수행되게 된다. [참조: JVM 메모리 구조](https://12bme.tistory.com/382) <br>
    ***위 정리된 자료 추후 다시 읽어보기***
    
    ##### Method, Class, Static 영역
    - 클래스 로더에 의해 바이트 코트로 분류된 데이터가 로드 되는 영역이다. 메소드 뿐만 아니라 static 변수도 이에 포함된다.
    - 이또한 Thread 별로 생성되는것이 아니라 모든 Thread 의전역적 접근이 가능하.
    
    ##### Native Method
    - 일반적인 메소드가 실행되는경우 Stack 영역에 적재가 되지만 Native 키워드가 붙은 native 메소드가 실행될 경우 이 영역에 할당되게 된다.

### 절차적/구조적 프로그래밍의 유산

```java
public class Start{

    public static void main(String[] args) {
        System.out.println("Hello World");
    }
}
```

> 위 코드가 실행될때 일어나는 과정을 메모리 관점에서 바라보도록 하자
1. class, Method 영역에 java.lang 패키지가 로드 된다. 모든 자바프로그램이 시작할때 반드시 로드 되는 패키지이다.
2. Start 클래스가 Class 영역에 로드된다.
3. main() 메서드가 호출되기 때문에 Stack 영역에 할당된다.
4. main 함수는 args 라는 파라미터를 받아 args 변수 또한 stack 영역에 할당된다.
5. 이후 println() 구문이 실행되면서 GPU 화면 출력 명령 전달
6. 스텍영역의 데이터 소멸 JVM 을 종료한후 JRE 영역또한 메모리에서 사라진다.

##### 멀티 스레드/ 멀티 프로세스의 이해

***멀티스레드의 개념은 스택영역을 스레드 개수만큼 분할해서 쓰는 것이다.***
> 스테틱 (Class, Method, Static) 영역과 힙 영역은 공유 되며 스텍 데이터 처리를 멀티 소팅이 이뤄진다.
- Servlet 을 예로 들었을 경우 하나의 요청당 하나의 프로세스가 아닌 하나의 쓰레드를 생성한다. 따라서 멀티 프로세스 대비 메모리를 적게 사용할 수 있는 구조이다.
- 


***멀티프로세스의 개념은 다수의 스태틱,스택,힙 영역의 메모리 구조를 갖는것이다***
> 서로 static, stack, heap 영역을 공유하지 않는다.
- 서로 메모리 영역을 침범하지 않는 안전한 구조이지만 메모리 사용량은 그만큼 크다.
 

> 객체지향 프로그래밍은 절차지향 프로그래밍의 유산을 간직하고 있으며 연산자 제어문 메모리 관리 체계 등등 많은 부분을 차용하고 있다. 객체 지향 프로그래밍도 
> 메서드 작성에 대한 지혜를 구조/절차적 프로그래밍에서 배워와야한다. 

## 03. 자바와 객체 지향

> 기계 종속적인 개발을 탈피하여 현실 세계처럼 프로그래밍을 할 수는 없을까 하는 고민 속에서 객체 지향의 개념이 탄생했다.
<br>

***객체와 클래스의 차이 실존(세상에 유일무이)하면 클래스 그것이 아니라면 객체이다***

객체: 사람, 새, 전자제품

클래스: SamsungGalaxyS5, 얀센백신, 스프링 입문을 위한 자바 객체 지향의 원리와 이해 도서


### 객체 지향의 4대 특성 

1. 캡슐화
2. 상속
> 객체의 상속은 부모와 자식의 관계의 관점으로 바라보는것이 아닌 상위와 하위, 슈퍼와 서브의 관점으로 바라봐야한다. 사람 -> 강호동, 표유류 -> 고래, 박쥐, 소, 말 조류 -> 참새, 독수리
```java
public class Test{

    public static void main(String[] args) {
        Animal animal1 = new 참새();
        Animal animal2 = new 독수리();
        Animal animal3 = new 고래();
        Animal animal4 = new 소();
        Animal animal5 = new 쥐();
    }
}
```
- 위와같이 상속의 개념은 상위클래스가 하위클래스에게 자원을 물려주는것이 아니다. 공통된 기능과 자원을 추상화한 데이터 를 가지며 하위 클래스는 공통 자원을 활용할 수 있다. 
모든 클래스는 Object 를 상속하고 있다 이에 모든 클래스는 toString() 이라는 메소드를 전역에서 사용할 수 있다.

- 상속은 is a kind of 관계를 만족해야 한다
  - 강호동은 사람중 하나이다. (O)
  - 컴퓨터는 가전제품중 하나이다. (O)
  - 아들은 아버지중 하나이다. (X)

3. 추상화
> 추상화는 곧 모델링이다. 구체적인 것을 분리해서 관심 영역에 대한 특성만을 가지고 재조합하는 것이며 사물을 복제하는것이 아니라 비즈니스 로직, 목적에 맞게 관심있는
> 특성만을 추출해서 표현하는것이다.
- 자바는 객체 지향의 추상화를 class 키워드로 지원하고 있다. interface, abstract
4. 다형성

#### 정적메서드의 사용
> 정적메서드는 객체의 존재 여부와 관계없이 JVM 구동시 static 영역에 로드되기때문에 주로 유틸리티성 메서드를 주로 사용하게 된다.

### 저자 추천사항
- 어셈블리어 서적을 1권을이라도 읽어보라.

    
    
        








</br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br>